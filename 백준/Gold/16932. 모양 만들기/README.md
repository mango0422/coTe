# [Gold III] 모양 만들기 - 16932 

[문제 링크](https://www.acmicpc.net/problem/16932) 

### 성능 요약

메모리: 333456 KB, 시간: 1684 ms

### 분류

너비 우선 탐색, 깊이 우선 탐색, 그래프 이론, 그래프 탐색

### 제출 일자

2025년 2월 12일 01:55:10

### 문제 설명

<p>N×M인 배열에서 모양을 찾으려고 한다. 배열의 각 칸에는 0과 1 중의 하나가 들어있다. 두 칸이 서로 변을 공유할때, 두 칸을 인접하다고 한다.</p>

<p>1이 들어 있는 인접한 칸끼리 연결했을 때, 각각의 연결 요소를 모양이라고 부르자. 모양의 크기는 모양에 포함되어 있는 1의 개수이다.</p>

<p>배열의 칸 하나에 들어있는 수를 변경해서 만들 수 있는 모양의 최대 크기를 구해보자.</p>

### 입력 

 <p>첫째 줄에 배열의 크기 N과 M이 주어진다. 둘째 줄부터 N개의 줄에는 배열에 들어있는 수가 주어진다.</p>

### 출력 

 <p>첫째 줄에 수 하나를 변경해서 만들 수 있는 모양의 최대 크기를 출력한다.</p>

### 🔍 코드 설명

이 코드는 **BFS(너비 우선 탐색)** 을 활용하여 **배열에서 1로 연결된 그룹(모양)을 찾고**,  
0을 1로 바꿀 때 **최대 모양 크기를 구하는 문제**를 해결한다.

---

### **🚀 코드 상세 설명**

#### **1️⃣ 그룹 찾기 (BFS)**
- `bfs(int x, int y, int g_id)` 함수는 **BFS 탐색을 이용해 연결된 1들을 그룹화**하는 역할을 한다.
- `g_map[][]`을 사용하여 각 칸이 **어느 그룹에 속하는지 표시**하고, `g_size`에 **각 그룹의 크기를 저장**한다.

#### **2️⃣ 0을 1로 바꾸고, 최대 크기 계산**
- `convertFunction(int x, int y)` 함수는 **주변 그룹을 찾고, 연결 가능한 그룹들의 크기를 합산**하여 가장 큰 모양을 만든다.
- **중복 방지**를 위해 `Set<Integer>`를 사용해 인접한 그룹들을 저장하고, `g_size`에서 크기를 가져와 합산한다.

---

### **⚡ 성능 분석**
#### **시간 복잡도**
1. **BFS 그룹 탐색**  
   - **O(N × M)**: 전체 배열을 탐색하면서 그룹을 찾음.
2. **0을 1로 바꾸면서 최대 크기 계산**  
   - **O(N × M)**: 각 0에 대해 인접한 그룹 크기를 합산하여 최대값을 찾음.

➡ **총 시간 복잡도: O(N × M)**  
(배열을 2번 탐색하므로, 크기가 `1000×1000`인 경우에도 수행 가능)

#### **공간 복잡도**
- `g_map[][]` 및 `arr[][]` : **O(N × M)**
- `g_size` 및 `Set<Integer>` : **O(K) (K는 그룹의 개수)**  
➡ **총 공간 복잡도: O(N × M)**

---

### **💡 개선 가능성**
- `g_map`과 `arr`을 같은 배열에서 관리하여 **메모리 사용량 절감 가능**
- `DFS`를 활용하여 `BFS`보다 스택을 적게 사용할 수도 있지만, **BFS가 더 안정적**
- `PriorityQueue`를 사용하여 **최대 모양 크기를 빠르게 갱신하는 방식도 고려 가능**

---

### **🛠 실행 예제**
#### **입력**
```
5 4
1 1 0 0
1 0 1 0
1 0 1 0
0 1 1 0
1 0 0 1
```
#### **출력**
```
9
```
#### **과정**
1. 그룹을 찾고 `g_map[][]`을 생성
```
2  2  0  0
2  0  3  0
2  0  3  0
0  3  3  0
4  0  0  5
```
2. 0을 1로 바꿀 때 최대 크기를 계산

---

### **🔗 결론**
✅ **BFS를 활용한 그룹 탐색 + 0을 1로 바꿨을 때의 최대 크기 탐색**  
✅ **O(N × M)으로 최적화된 풀이**  
✅ **다른 최적화 방법 가능성 존재 (메모리 절약, `PriorityQueue` 활용 등)**  

---
